#!/usr/bin/env ruby

# -------------------------------------------------------------------------- #
# Copyright 2002-2018, OpenNebula Project, OpenNebula Systems                #
#                                                                            #
# Licensed under the Apache License, Version 2.0 (the "License"); you may    #
# not use this file except in compliance with the License. You may obtain    #
# a copy of the License at                                                   #
#                                                                            #
# http://www.apache.org/licenses/LICENSE-2.0                                 #
#                                                                            #
# Unless required by applicable law or agreed to in writing, software        #
# distributed under the License is distributed on an "AS IS" BASIS,          #
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   #
# See the License for the specific language governing permissions and        #
# limitations under the License.                                             #
#--------------------------------------------------------------------------- #

require_relative 'lib/container'
require_relative 'lib/client'
require_relative '../lib/poll_common'

################################################################################
#
#  LXD Monitor Module
#
################################################################################
module LXD

    CLIENT = LXDClient.new

    class << self

        # Get the information of a single VM. In case of error the VM is reported
        # as not found.
        # @param vm_id [String] with the VM information
        def get_vm_info(one_vm)
            vm = Container.get(one_vm, CLIENT)

            return { :state => '-' } unless vm

            values = get_values(vm)

            return values
        end

        def get_values(container)
            values =  {
                :name => container.name,
                :state => get_state(container)
            }
            return values unless values[:state] == 'a'

            values[:cpu] = get_cpu(container.name)
            values[:memory] = get_memory(container.name)

            values
        end

        def get_state(container)
            begin
                status = container.status.downcase
            rescue StandardError
                status = 'unknown'
            end

            case status
            when 'running'
                state = 'a'
            when 'frozen'
                state = 'p'
            when 'stopped'
                state = 'd'
            when 'failure'
                state = 'e'
            else
                state = '-'
            end

            state
        end

        def get_memory(vm_name)
            stat = File.read('/sys/fs/cgroup/memory/lxc/' + vm_name + '/memory.usage_in_bytes').to_i
            stat / 1024
        end

        def get_cpu(vm_name)
            multiplier = %x{nproc}.to_i * 100

            start_cpu_jiffies = get_cpu_jiffies
            start_cpu_used = get_process_jiffies(vm_name).to_f

            sleep 1

            cpu_jiffies = get_cpu_jiffies - start_cpu_jiffies

            cpu_used = (get_process_jiffies(vm_name) - start_cpu_used) / cpu_jiffies
            cpu_used = (cpu_used * multiplier).round(2)

            cpu_used
        end

        def get_cpu_jiffies
            begin
                stat = File.read('/proc/stat')
            rescue StandardError
                return 0
            end

            jiffies = 0

            # skip cpu string and guest jiffies
            stat.lines.first.split(' ')[1..-3].each do |num|
                jiffies += num.to_i
            end

            jiffies
        end

        def get_process_jiffies(vm_name)
            begin
                jiffies = 0
                stat = File.read('/sys/fs/cgroup/cpu,cpuacct/lxc/' + vm_name + '/cpuacct.stat')
                stat.lines.each {|line| jiffies += line.split(' ')[1] }
            rescue StandardError
                return 0
            end

            jiffies
        end

    end

end

################################################################################
# MAIN PROGRAM
################################################################################

hypervisor = LXD
# file       = '../../etc/vmm/kvm/kvmrc'

# load_vars(hypervisor)

vm_id = ARGV[0]

if vm_id == '-t'
    print_all_vm_template(hypervisor)
elsif vm_id
    print_one_vm_info(hypervisor, vm_id)
else
    print_all_vm_info(hypervisor)
end
